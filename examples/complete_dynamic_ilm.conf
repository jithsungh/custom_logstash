# Complete Dynamic ILM Configuration Example
# This configuration creates dynamic indices, templates, and ILM policies per container

input {
  kafka {
    bootstrap_servers => "10.50.0.199:9092"
    topics => ["dev.test"]
    group_id => "logstash-test"
    enable_auto_commit => false
    consumer_threads => 20
    max_poll_records => 500
    max_poll_interval_ms => 300000
    codec => json
    decorate_events => true
  }
}

filter {
  # Extract container_name from kubernetes metadata
  if [kubernetes][container_name] {
    ruby {
      code => '
        c = event.get("[kubernetes][container_name]")
        event.set("container_name", c.is_a?(Array) ? c.first : c)
      '
    }
  }

  # Parse logs based on container
  if [container_name] == "dotcms" {
    grok {
      match => {
        "log" => "%{TIME:time}%{SPACE}%{LOGLEVEL:log_level}%{SPACE}%{DATA:component}%{SPACE}-%{SPACE}%{GREEDYDATA:log_message}"
      }
      tag_on_failure => []
    }
    mutate {
      lowercase => ["log_level"]
      add_field => {
        "full_timestamp" => "%{+YYYY-MM-dd} %{time}"
        "[json][Service]" => "dotcms"
      }
    }
    date {
      match => ["full_timestamp", "YYYY-MM-dd HH:mm:ss.SSS"]
      target => "@timestamp"
    }
    mutate {
      remove_field => ["full_timestamp", "time"]
    }
  }

  # Handle grok parse failures
  if "_grokparsefailure" in [tags] {
    mutate {
      update => { "container_name" => "grokparsefailure" }
    }
  }

  # Set default container_name if missing
  if ![container_name] {
    mutate {
      add_field => { "container_name" => "unknown-service" }
    }
  }

  # Normalize container_name for index naming
  mutate {
    gsub => [
      "container_name", "[^a-z0-9_-]", "_",
      "container_name", "^-+|-+$", "",
      "container_name", "--+", "-"
    ]
    lowercase => ["container_name"]
  }
}

output {
  elasticsearch {
    hosts => ["eck-es-http:9200"]
    user => "elastic"
    password => "password"
    ssl_enabled => false
    ecs_compatibility => "disabled"

    # Enable ILM with dynamic rollover alias (uses container_name from each event)
    ilm_enabled => true
    ilm_rollover_alias => "%{[container_name]}"
    
    # ============================================
    # Dynamic ILM Policy Configuration
    # ============================================
    # These settings apply to ALL dynamically created ILM policies
    # Each container gets its own policy: <container-name>-ilm-policy
    
    # Hot phase: Rollover conditions
    ilm_rollover_max_age => "1d"       # Rollover after 1 day (default)
    # ilm_rollover_max_size => "50gb"  # Optional: Rollover after 50GB
    # ilm_rollover_max_docs => 1000000 # Optional: Rollover after 1M docs
    
    # Hot phase: Index priority (higher = recovered first after restart)
    ilm_hot_priority => 50             # Default: 50
    
    # Delete phase: When to delete old indices
    ilm_delete_min_age => "1d"        # Delete indices after 1 day (default)
    ilm_delete_enabled => true         # Enable automatic deletion (default: true)
    
    # ============================================
    # What Gets Created Dynamically:
    # ============================================
    # For container "nginx", the plugin will create:
    # 1. ILM Policy:  nginx-ilm-policy
    # 2. Template:    logstash-nginx (matches nginx-*)
    # 3. Index:       nginx-000001 (with rollover alias "nginx")
    # 
    # For container "app1", it creates:
    # 1. ILM Policy:  app1-ilm-policy
    # 2. Template:    logstash-app1 (matches app1-*)
    # 3. Index:       app1-000001 (with rollover alias "app1")
    #
    # And so on for each unique container_name value
  }
}

# ============================================
# Example Scenarios
# ============================================

# Scenario 1: Short retention for test data
# For "test" container, manually edit "test-ilm-policy" in Kibana:
# DELETE phase min_age: "6h" instead of "1d"

# Scenario 2: Long retention for audit logs  
# For "audit" container, manually edit "audit-ilm-policy" in Kibana:
# DELETE phase min_age: "90d" instead of "1d"

# Scenario 3: Large rollover for high-volume service
# For "api" container, manually edit "api-ilm-policy" in Kibana:
# HOT phase rollover: max_size "100gb" in addition to max_age

# NOTE: Manual changes in Kibana are PRESERVED
# The plugin only creates policies once, it never overwrites existing ones
